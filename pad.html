<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>

<body>
    <canvas id="cnvs" style="width: 300px; height: 300px;"></canvas>

    <script type="module">

        import * as THREE from './js/three.module.js';

        import { OrbitControls } from './js/OrbitControls.js';

        var camera, controls, scene, renderer;

        init();
        render(); // remove when using next line for animation loop (requestAnimationFrame)
        //animate();

        function init() {

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xaaaaaa );
            //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                canvas: document.getElementById("cnvs")
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(300, 300);
            //document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, 1, 1, 2000);
            camera.position.set(400, 200, 0);

            // controls

            controls = new OrbitControls(camera, renderer.domElement);

            controls.addEventListener('change', render); // call this only in static scenes (i.e., if there is no animation loop)

            // controls.enableDamping = false; // an animation loop is required when either damping or auto-rotation are enabled
            // controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = -1500;
            controls.maxDistance = 1500;

            //controls.maxPolarAngle = Math.PI / 2;

            // world

            var geometry = new THREE.BoxBufferGeometry(300, 200, 100);
            var material = new THREE.MeshPhongMaterial({ color: 0xdddddd, flatShading: true });

            var wireframe = new THREE.EdgesGeometry( geometry );

            var line = new THREE.LineSegments( wireframe );
            line.material.depthTest = false;
            //line.material.opacity = 0.25;
            //line.material.transparent = true;

            scene.add( line );

            // for (var i = 0; i < 500; i++) {

                // var mesh = new THREE.Mesh(geometry, material);
                // // mesh.position.x = Math.random() * 1600 - 800;
                // // mesh.position.y = 0;
                // // mesh.position.z = Math.random() * 1600 - 800;
                // mesh.updateMatrix();
                // mesh.matrixAutoUpdate = false;
                // scene.add(mesh);

            // }

            // lights

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1000, 1000, 1000);
            scene.add(light);

            // var light = new THREE.DirectionalLight(0x002288);
            // light.position.set(- 1, - 1, - 1);
            // scene.add(light);

            // var light = new THREE.AmbientLight(0xffffff);
            // scene.add(light);

            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            //controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

            render();

        }

        function render() {

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>