<!DOCTYPE html>
<html lang="en">

<head>
    <title>three.js webgl - orbit controls</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <script src="geometry/geometries3d.js"></script>
    <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
    <style>
        body {
            background-color: #ccc;
            color: #000;
        }

        a {
            color: #f00;
        }
    </style>
</head>

<body>
    <canvas id="cnvs" style="width: 300px; height: 300px;"></canvas>

    <script type="module">

        import * as THREE from './js/three.module.js';

        import { OrbitControls } from './js/OrbitControls.js';

        var camera, controls, scene, renderer;

        init();
        render(); // remove when using next line for animation loop (requestAnimationFrame)
        //animate();

        function init() {

            scene = new THREE.Scene();
            scene.background = new THREE.Color( 0xaaaaaa );
            //scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

            renderer = new THREE.WebGLRenderer({
                antialias: true,
                canvas: document.getElementById("cnvs")
            });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(300, 300);
            //document.body.appendChild(renderer.domElement);

            //camera = new THREE.PerspectiveCamera(50, 1, 1, 3000);
            camera.position.set(1100, 0, 1100);


            // controls

            controls = new OrbitControls(camera, renderer.domElement);

            controls.addEventListener('change', render); // call this only in static scenes (i.e., if there is no animation loop)

            // controls.enableDamping = false; // an animation loop is required when either damping or auto-rotation are enabled
            // controls.dampingFactor = 0.05;

            controls.screenSpacePanning = false;

            controls.minDistance = -3000;
            controls.maxDistance = 3000;

            //controls.maxPolarAngle = Math.PI / 2;

            // world

            //var material = new THREE.MeshPhongMaterial({ color: 0xdddddd, flatShading: true });
            var material = new THREE.LineBasicMaterial( { color: 0x0000ff } );

            const sphG = new THREE.SphereBufferGeometry(10);
            scene.add(new THREE.LineSegments(new THREE.WireframeGeometry(sphG), new THREE.LineBasicMaterial( { color: 0xff0000 } )));

            const detectors = new THREE.Object3D();

            for (const layer of geomLayers3D()) {
                //if (layer.lyr != 0) continue;
                const rotObj = new THREE.Object3D();
                rotObj.rotation.fromArray([0, 0, layer.rot / 180 * Math.PI]);

                var geometry = new THREE.BoxBufferGeometry(layer.w, layer.h, layer.d);
                var wireframe = new THREE.EdgesGeometry( geometry );
                var line = new THREE.LineSegments( wireframe, 
                    new THREE.LineBasicMaterial( { color: new THREE.Color(`hsl(${layer.rot}, ${20 + layer.lyr * 10}%, ${20 + layer.stk * 10}%)`) } ) 
                );
                line.position.x = layer.x;
                line.position.y = layer.y;
                line.position.z = layer.z;
                
                rotObj.add( line );
            
                detectors.add( rotObj );
            }

            scene.add(detectors);
            // line.material.depthTest = false;
            // line.material.opacity = 0.25;
            // line.material.transparent = true;

            // for (var i = 0; i < 500; i++) {

                // var mesh = new THREE.Mesh(geometry, material);
                // // mesh.position.x = Math.random() * 1600 - 800;
                // // mesh.position.y = 0;
                // // mesh.position.z = Math.random() * 1600 - 800;
                // mesh.updateMatrix();
                // mesh.matrixAutoUpdate = false;
                // scene.add(mesh);

            // }

            // lights

            var light = new THREE.DirectionalLight(0xffffff);
            light.position.set(1000, 1000, 1000);
            scene.add(light);

            // var light = new THREE.DirectionalLight(0x002288);
            // light.position.set(- 1, - 1, - 1);
            // scene.add(light);

            // var light = new THREE.AmbientLight(0xffffff);
            // scene.add(light);

            //

            window.addEventListener('resize', onWindowResize, false);

        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }

        function animate() {

            requestAnimationFrame(animate);

            //controls.update(); // only required if controls.enableDamping = true, or if controls.autoRotate = true

            render();

        }

        function render() {

            renderer.render(scene, camera);

        }

    </script>

</body>

</html>