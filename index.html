<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css"> -->
    <link href='./bootstrap/css/bootstrap.min.css' rel='stylesheet' />
    <link href='./proton/style.min.css' rel='stylesheet' />
    <script src="d3.min.js"></script>
    <script src="jquery.min.js"></script>
    <script src="jstree.min.js"></script>
    <script src="data.js"></script>
    <style>
        svg {
            border: 1px solid black;
        }

        .SSC-stack-text {
            text-anchor: middle;
            dominant-baseline: central;
        }

        .SSC-stack-index {
            text-anchor: middle;
            dominant-baseline: central;
            font-size: xx-small;
            fill: #555;
        }

        .SSC-sector-text {
            text-anchor: middle;
            dominant-baseline: central;

        }

        .SSC-sector-index {
            text-anchor: middle;
            dominant-baseline: central;
            font-size: xx-small;
            fill: #555;
        }

        .SSC-LinearStack {
            fill: none;
            stroke: black;
        }

        .SSC-LinearStack.SSC-hit {
            fill: lightslategray;
        }

        .SSC-LinearStack.SSC-hit.SSC-selected {
            fill: red;
        }

        .SLC-sector-index {
            text-anchor: start;
            dominant-baseline: central;
            font-size: xx-small;
            fill: #555;
        }

        .SLC-Supermodule {
            fill: none;
            stroke: black;
        }

        .SLC-supermodule-header {
            text-anchor: middle;
            dominant-baseline: central;
        }

        .SLC-Supermodule.SLC-hit {
            fill: lightslategray;
        }

        .SLC-Supermodule.SLC-hit.SLC-selected {
            fill: red;
        }

        .STLC-roc {
            stroke: black;
            fill: none;
        }

        .STLC-roc.STLC-hit {
            fill: lightslategray;
        }

        .STLC-roc.STLC-hit.STLC-selected {
            fill: red;
        }

        path.TP {
            stroke: darkgray;
            fill: none;
            stroke-dasharray: 4;
        }

        path.TP.TP-selected {
            stroke: red;
            stroke-width: 4px;
            fill: none;
            stroke-dasharray: none;
        }
    </style>
</head>

<body>
    <div style="width: 300px; max-height: 400px; overflow: auto; display: inline-block; vertical-align: top;">
        <div id="dataTree">

        </div>

    </div>

    <div style="display:inline-block;">
        <div>
            <div style="display: inline-block;">
                <svg id="sectorLayer" width="300px">

                </svg>
            </div>
            <div style="display: inline-block;">
                <svg id="stackLayer" width="300px" height="300px" preserveAspectRatio="xMidYMid meet">

                </svg>
            </div>
            <div style="display: inline-block;">
                <svg id="stackSector" height="300px" width="300px">

                </svg>
            </div>
        </div>
        <div>
            <div style="display: inline-block;">
                <svg id="trackPathXY" width="300px" height="300px" preserveAspectRatio="xMidYMid meet">

                </svg>
            </div>
            <div style="display: inline-block;">
                <svg id="trackPathZY" width="300px" height="300px" preserveAspectRatio="xMidYMid meet">

                </svg>
            </div>
            <div style="display: inline-block;">
                <svg id="trackPathZX" width="300px" height="300px" preserveAspectRatio="xMidYMid meet">

                </svg>
            </div>
        </div>
    </div>
    <script>
        // Constants
        const nSTACKS = 5;
        const nSECTORS = 18;
        const nLAYERS = 6;
        const nLINEARSTACKS = nSTACKS * nSECTORS;

        // Conventions
        // LinearStackIndex = Sector * nSTACKS + Stack
        // Detector = LinearStackIndex * nLAYERS + Layer

        // Common functions
        function DetectorToStack(detector) { return Math.floor((detector % (nSTACKS * nLAYERS)) / nLAYERS); } // convert detector (=chamber) number 0-539 to local stack index 0-4
        function DetectorToLayer(detector) { return detector % nLAYERS; } // convert detector (=chamber) number 0-539 to local layer 0-5
        function DetectorToLinearStackIndex(detector) { return Math.floor(detector / nLAYERS); } // convert TRD detector/chamber 0-539 index to linear stack index 0-89
        function DetectorToSector(detector) { return Math.floor(detector / nLAYERS / nSTACKS); } // convert linear stack index 0-89 to TRD sector 0-17
        function StackSectorToLinearStackIndex(stack, sector) { return sector * nSTACKS + stack; } // convert sector 0-17 and stack 0-5 to linear stack index 0-89
    </script>
    <script>
        // Data conversions
        function parseTrdTracklet(t) {
            return {
                Stack: DetectorToStack(t.Detector),
                Sector: DetectorToSector(t.Detector),
                Layer: DetectorToLayer(t.Detector),
                LinearStackIndex: DetectorToLinearStackIndex(t.Detector),
                Chamber: t.HCId % 2,
                Detector: t.Detector,
                HCId: t.HCId,
                Index: t.index
            };
        }
        function parseTrdTrack(d) {
            return {
                Stack: d.Stack,
                Sector: d.Sector,
                LinearStackIndex: StackSectorToLinearStackIndex(d.Stack, d.Sector),
                Index: d.index,
                Tracklets: d.TrdTracklets.map(parseTrdTracklet)
            };
        }
        function getTrdTracks(event) {
            return event.TrdTracks.map(parseTrdTrack);
        }
    </script>
    <script>
        // D3 components
        class BaseComponent {
            constructor(width, height, margin) {
                this.height = height;
                this.width = width;

                if (margin != null) {
                    this.height -= +margin.vert;
                    this.width -= +margin.horiz;
                }
            }
        }

        class StackSectorComponent extends BaseComponent {
            constructor(width, height, parent) {
                const margin = { n: 30, s: 10, e: 30, w: 5 };
                margin.vert = margin.n + margin.s;
                margin.horiz = margin.e + margin.w;

                super(width, height, margin);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                this.componentg = parent.append("g").attr("class", "stackSector");

                this.headerg = this.componentg.append("g");

                this.headerg.append("text")
                    .text("Stack")
                    .attr("class", "SSC-stack-text")
                    .attr("transform", "translate(" + (margin.e + this.width / 2) + "," + (margin.n / 3) + ")");

                this.headerg.append("text")
                    .text("Sector")
                    .attr("class", "SSC-sector-text")
                    .attr("transform", "translate(" + (margin.e / 3) + "," + (margin.n + this.height / 2) + ")rotate(-90)");

                this.headerg.selectAll("text.SSC-stack-index")
                    .data(d3.range(nSTACKS))
                    .enter()
                    .append("text")
                    .attr("class", "SSC-stack-index")
                    .text(d => d)
                    .attr("transform", d => "translate(" + (margin.e + (d + 0.5) * componentWidth) + "," + (margin.n * 4 / 5) + ")");

                this.headerg.selectAll("text.SSC-sector-index")
                    .data(d3.range(nSECTORS))
                    .enter()
                    .append("text")
                    .attr("class", "SSC-sector-index")
                    .text(d => d)
                    .attr("transform", d => "translate(" + (margin.e * 4 / 5) + "," + (margin.n + (d + 0.5) * componentHeight) + ")");

                this.g = this.componentg.append("g")
                    .attr("transform", "translate(" + margin.e + "," + margin.n + ")");

                this.linearStackData = d3.range(nLINEARSTACKS)
                    .map(d => ({ index: d, selected: false, tracks: [] }));

                this.linearStacks = this.g.selectAll("g.SSC-LinearStack")
                    .data(this.linearStackData)
                    .enter()
                    .append("g")
                    .attr("class", "SSC-LinearStack")
                    .attr("transform", d => "translate(" + ((d.index % nSTACKS) * componentWidth) + "," + (Math.floor(d.index / nSTACKS) * componentHeight) + ")");

                this.linearStacks.append("circle")
                    .attr("cx", componentWidth / 2)
                    .attr("cy", componentHeight / 2)
                    .attr("r", Math.min(componentWidth, componentHeight) * 1 / 3);
            }

            draw(event, selectedTrdTrack) {
                const trdTracks = getTrdTracks(event);

                for (const lsd of this.linearStackData) {
                    lsd.tracks = [];
                    lsd.selected = false;
                }

                for (const trdTrack of trdTracks) {
                    this.linearStackData[trdTrack.LinearStackIndex].tracks.push(trdTrack);
                    if (selectedTrdTrack != null && trdTrack.Index == selectedTrdTrack.index)
                        this.linearStackData[trdTrack.LinearStackIndex].selected = true;
                }

                this.g.selectAll("g.SSC-LinearStack")
                    .classed("SSC-hit", d => d.tracks.length > 0)
                    .classed("SSC-selected", d => d.selected);
            }
        }

        class SectorLayerComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                const minRadius = 30;
                const layerHeight = 10;

                parent.append("text")
                    .text("Supermodules")
                    .attr("class", "SLC-supermodule-header")
                    .attr("x", this.width / 2)
                    .attr("y", 15);

                this.g = parent.append("g").attr("class", "stackSector")
                    .attr("transform", "translate(15,30)");

                this.sectorLayerData = d3.range(nSECTORS * nLAYERS)
                    .map(d => {
                        const layer = d % nLAYERS;
                        const height = 10 + layer * 3.6;
                        return {
                            index: d,
                            sector: Math.floor(d / nLAYERS),
                            layer: layer,
                            tracks: [],
                            x: minRadius + layerHeight * layer,
                            y: -height / 2,
                            width: layerHeight,
                            height: height
                        };
                    });

                this.sectorLayers = this.g.selectAll("g.SLC-Supermodule")
                    .data(this.sectorLayerData)
                    .enter()
                    .append("g")
                    .attr("class", "SLC-Supermodule ")
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")rotate(" + (-10 - d.sector / nSECTORS * 360) + ")");

                this.g.selectAll("text.SLC-sector-index")
                    .data(d3.range(nSECTORS))
                    .enter()
                    .append("text")
                    .attr("class", "SLC-sector-index")
                    .text(d => d)
                    .attr("x", minRadius + (layerHeight + 0.5) * nLAYERS)
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")rotate(" + (-10 - d / nSECTORS * 360) + ")");

                this.sectorLayers.append("rect")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("width", d => d.width)
                    .attr("height", d => d.height);
            }

            draw(event, selectedTracklets) {
                const trdTracklets = event.TrdTracklets.map(parseTrdTracklet);

                for (const sld of this.sectorLayerData) {
                    sld.tracks = [];
                    sld.selected = false;
                }

                for (const trdTracklet of trdTracklets) {
                    const sld = this.sectorLayerData[trdTracklet.Sector * nLAYERS + trdTracklet.Layer];
                    sld.tracks.push(trdTracklet);
                    for (const selTracklet of selectedTracklets)
                        if (trdTracklet.Index == selTracklet.index)
                            sld.selected = true;
                }

                this.g.selectAll("g.SLC-Supermodule")
                    .classed("SLC-hit", d => d.tracks.length > 0)
                    .classed("SLC-selected", d => d.selected);
            }
        }

        const STACK_LAYER_WIDTHS = [
            [70, 65, 60, 65, 70],
            [70, 65, 60, 65, 70],
            [80, 70, 60, 70, 80],
            [90, 75, 60, 75, 90],
            [100, 80, 60, 80, 100],
            [110, 85, 60, 85, 110],
        ];

        class StackLayerComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nLAYERS;

                const layerHeight = 30;

                this.g = parent.append("g").attr("class", "stackLayer");

                this.stackLayerData = d3.range(nSTACKS * nLAYERS)
                    .map(d => {
                        const layer = d % nLAYERS;
                        const stack = Math.floor(d / nLAYERS);
                        let x = -STACK_LAYER_WIDTHS[layer].reduce((a, b) => a + b) / 2;

                        let stackIndex = 0, width = 0;
                        while (stackIndex < stack)
                            x += STACK_LAYER_WIDTHS[layer][stackIndex++];
                        width = STACK_LAYER_WIDTHS[layer][stackIndex];

                        return {
                            index: d,
                            stack: stack,
                            layer: layer,
                            x: x,
                            y: (2 - layer) * layerHeight,
                            width: width,
                            height: layerHeight,
                            tracks: [],
                            selected: false
                        };
                    });

                this.stackLayers = this.g.selectAll("g.STLC-roc")
                    .data(this.stackLayerData)
                    .enter()
                    .append("g")
                    .attr("class", "STLC-roc")
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")");

                this.stackLayers.append("rect")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("width", d => d.width)
                    .attr("height", d => d.height);
            }

            draw(event, selectedTracklets) {
                const trdTracklets = event.TrdTracklets.map(parseTrdTracklet);

                for (const sld of this.stackLayerData) {
                    sld.tracks = [];
                    sld.selected = false;
                }

                for (const trdTracklet of trdTracklets) {
                    const sld = this.stackLayerData[trdTracklet.Stack * nLAYERS + trdTracklet.Layer];
                    sld.tracks.push(trdTracklet);
                    for (const selTracklet of selectedTracklets)
                        if (trdTracklet.Index == selTracklet.index)
                            sld.selected = true;
                }

                this.g.selectAll("g.STLC-roc")
                    .classed("STLC-hit", d => d.tracks.length > 0)
                    .classed("STLC-selected", d => d.selected);
            }
        }

        class TrackPathComponent extends BaseComponent {
            constructor(width, height, parent, xlab, ylab, horixIndex, vertIndex, xsign = 1, ysign = 1) {
                super(width, height);

                this.horixIndex = horixIndex;
                this.vertIndex = vertIndex;

                this.g = parent.append("g").attr("class", "trackPath")
                    .attr("transform", "translate(" + this.width / 2 + "," + this.height / 2 + ")");

                const minDim = 0.9 * Math.min(this.width, this.height) / 2;

                const xscale = this.xscale = d3.scaleLinear()
                    .range([-minDim * xsign, minDim * xsign])
                    .domain([-370, 370]);

                const yscale = this.yscale = d3.scaleLinear()
                    .range([minDim * ysign, -minDim * ysign])
                    .domain([-370, 370]);

                this.line = d3.line().x(d => xscale(d[horixIndex])).y(d => yscale(d[vertIndex]));

                this.xaxis = d3.axisBottom(this.xscale);
                this.yaxis = d3.axisLeft(this.yscale);

                this.g.append("g")
                    .attr("class", "x-axis")
                    .call(this.xaxis);

                this.g.append("g")
                    .attr("class", "y-axis")
                    .call(this.yaxis);

                this.paths = this.g.append("g")
                    .attr("class", "paths");

                this.g.append("text")
                    .attr("class", "y-label")
                    .attr("y", this.yscale.range()[1])
                    .attr("x", 10)
                    .text(ylab);

                this.g.append("text")
                    .attr("class", "x-label")
                    .attr("x", this.xscale.range()[1])
                    .attr("y", -10)
                    .text(xlab);
            }

            draw(event, selectedTrack) {
                const trackPaths = event.TrdTracks.filter(d => d.TrackMatch != null && d.TrackMatch.Path != null);
                const line = this.line;

                const selection = this.paths.selectAll("path.TP")
                    .data(trackPaths)
                    .join(
                        enter => enter.append("path").attr("class", "TP"),
                        null,
                        exit => exit.remove()
                    )
                    .attr("data-track-ref", d => d.Ref)
                    .attr("d", d => line(d.TrackMatch.Path))
                    .classed("TP-selected", d => selectedTrack != null && d.index == selectedTrack.index)
                    ;
            }
        }
    </script>
    <script>
        // JSTree conversion functions
        function trdTrackletToJseTreeNode(parentId, t) {
            return {
                id: parentId + "_L" + t.index,
                text: "Stack: " + DetectorToStack(t.Detector) + " Sector: " + DetectorToSector(t.Detector) + " Layer: " + DetectorToLayer(t.Detector),
                data: t,
                type: "TrdTracklet"
            };
        }

        function trdTrackToJSTreeNode(parentId, t) {
            return {
                id: parentId + "_T" + t.index,
                text: "TrdTrack " + t.Id + " Stack: " + t.Stack + " Sector: " + t.Sector,
                data: t,
                type: "TrdTrack",
                children: t.TrdTracklets.map(tlt => trdTrackletToJseTreeNode(parentId + "_T" + t.index, tlt))
            };
        }

        function eventToJSTreeNode(e, index) {
            const id = "E" + index;
            return {
                id: id,
                text: "Event " + e.Event,
                type: "Event",
                data: e,
                state: {
                    opened: false,
                },
                children:
                    e.TrdTracks.map(tr => trdTrackToJSTreeNode(id, tr))
                        .concat([{
                            id: id + "_CTracklets",
                            text: "Tracklets",
                            children: e.TrdTracklets.map(tlt => trdTrackletToJseTreeNode(id, tlt))
                        }])
            };
        }
    </script>
    <script>
        // Event Display
        const stackSector = new StackSectorComponent(100, 200, d3.select("#stackSector")
            .attr("viewBox", "0 0 100 200"));
        const sectorLayer = new SectorLayerComponent(200, 200, d3.select("#sectorLayer")
            .attr("viewBox", "0 0 250 250"));
        const stackLayer = new StackLayerComponent(600, 300, d3.select("#stackLayer")
            .attr("viewBox", "0 0 600 300"));
        const trackPathXY = new TrackPathComponent(300, 300, d3.select("#trackPathXY")
            .attr("viewBox", "0 0 300 300"), "X", "Y", 0, 1);
        const trackPathZY = new TrackPathComponent(300, 300, d3.select("#trackPathZY")
            .attr("viewBox", "0 0 300 300"), "Z", "Y", 2, 1, -1, 1);
        const trackPathZX = new TrackPathComponent(300, 300, d3.select("#trackPathZX")
            .attr("viewBox", "0 0 300 300"), "Z", "X", 2, 0, -1, 1);
        const data = getData();

        for (const event of data) {
            for (let index = 0; index < event.TrdTracklets.length; index++) {
                event.TrdTracklets[index].index = index;
            }

            for (let trdTrackIndex = 0; trdTrackIndex < event.TrdTracks.length; trdTrackIndex++) {
                event.TrdTracks[trdTrackIndex].index = trdTrackIndex;

                for (const trackTracklet of event.TrdTracks[trdTrackIndex].TrdTracklets) {
                    for (const trdTracklet of event.TrdTracklets)
                        if (trdTracklet.Ref === trackTracklet.Ref)
                            trackTracklet.index = trdTracklet.index;
                }
            }
        }

        const treeData = data.map(eventToJSTreeNode);

        function treeSelect(event, eventData) {
            const ids = eventData.node.id.split("_").map(d => [d[0], d.slice(1)]);
            var event = null, trdTrack = null, trdTracklets = [];
            for (const id of ids) {
                const prefix = id[0];
                const index = id[1];
                //console.log(prefix, index);
                if (prefix == "E")
                    event = data[+index];

                if (prefix == "T" && event != null) {
                    trdTrack = event.TrdTracks[+index];
                    trdTracklets = trdTrack.TrdTracklets;
                }

                if (prefix == "L" && event != null) {
                    trdTracklets = [event.TrdTracklets[+index]];
                }
            }

            if (event != null) {
                stackSector.draw(event, trdTrack);
                sectorLayer.draw(event, trdTracklets);
                stackLayer.draw(event, trdTracklets);
                trackPathXY.draw(event, trdTrack);
                trackPathZY.draw(event, trdTrack);
                trackPathZX.draw(event, trdTrack);
            }
        }

        $("#dataTree")
            .on("hover_node.jstree", treeSelect)
            .jstree({
                'core': {
                    'themes': {
                        'name': 'proton',
                        'responsive': true
                    },
                    'data': treeData
                }
            })
    </script>
</body>

</html>