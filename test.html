<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css"> -->
    <link href='./bootstrap/css/bootstrap.min.css' rel='stylesheet' />
    <link href='./proton/style.min.css' rel='stylesheet' />
    <script src="d3.min.js"></script>
    <script src="jquery.min.js"></script>
    <script src="jstree.min.js"></script>
    <script src="data.js"></script>
    <style>
        .SSC-LinearStack {
            fill: none;
            stroke: black;
        }

        .SSC-LinearStack.SSC-hit {
            fill: lightslategray;
        }

        .SSC-LinearStack.SSC-hit.SSC-selected {
            fill: red;
        }

        .SLC-Supermodule {
            fill: none;
            stroke: black;
        }

        .SLC-Supermodule.SLC-hit {
            fill: lightslategray;
        }

        .SLC-Supermodule.SLC-hit.SLC-selected {
            fill: red;
        }

        .STLC-roc {
            stroke: black;
            fill: none;
        }

        .STLC-roc.STLC-hit {
            fill: lightslategray;
        }

        .STLC-roc.STLC-hit.STLC-selected {
            fill: red;
        }
    </style>
</head>

<body>
    <div style="width: 200px; max-height: 400px; overflow: auto; display: inline-block; vertical-align: top;">
        <div id="dataTree">

        </div>

    </div>
    <div style="display: inline-block;">
        <svg id="stackSector" width="200px">

        </svg>
    </div>
    <div style="display: inline-block;">
        <svg id="sectorLayer" width="400px">

        </svg>
    </div>
    <div style="display: inline-block;">
        <svg id="stackLayer" width="400px">

        </svg>
    </div>
    <script>
        // Constants
        const nSTACKS = 5;
        const nSECTORS = 18;
        const nLAYERS = 6;
        const nLINEARSTACKS = nSTACKS * nSECTORS;

        // Conventions
        // LinearStackIndex = Sector * nSTACKS + Stack
        // Detector = LinearStackIndex * nLAYERS + Layer

        // Common functions
        function DetectorToStack(detector) { return Math.floor((detector % (nSTACKS * nLAYERS)) / nLAYERS); } // convert detector (=chamber) number 0-539 to local stack index 0-4
        function DetectorToLayer(detector) { return detector % nLAYERS; } // convert detector (=chamber) number 0-539 to local layer 0-5
        function DetectorToLinearStackIndex(detector) { return Math.floor(detector / nLAYERS); } // convert TRD detector/chamber 0-539 index to linear stack index 0-89
        function DetectorToSector(detector) { return Math.floor(detector / nLAYERS / nSTACKS); } // convert linear stack index 0-89 to TRD sector 0-17
        function StackSectorToLinearStackIndex(stack, sector) { return sector * nSTACKS + stack; } // convert sector 0-17 and stack 0-5 to linear stack index 0-89
    </script>
    <script>
        // Data conversions
        function parseTrdTracklet(t) {
            return {
                Stack: DetectorToStack(t.Detector),
                Sector: DetectorToSector(t.Detector),
                Layer: DetectorToLayer(t.Detector),
                LinearStackIndex: DetectorToLinearStackIndex(t.Detector),
                Chamber: t.HCId % 2,
                Detector: t.Detector,
                HCId: t.HCId,
                Index: t.index
            };
        }
        function parseTrdTrack(d) {
            return {
                Stack: d.Stack,
                Sector: d.Sector,
                LinearStackIndex: StackSectorToLinearStackIndex(d.Sector, d.Stack),
                Index: d.index,
                Tracklets: d.TrdTracklets.map(parseTrdTracklet)
            };
        }
        function getTrdTracks(event) {
            return event.TrdTracks.map(parseTrdTrack);
        }
    </script>
    <script>
        // D3 components
        class BaseComponent {
            constructor(width, height) {
                this.height = height;
                this.width = width;
            }
        }

        class StackSectorComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                this.g = parent.append("g").attr("class", "stackSector");

                this.linearStackData = d3.range(nLINEARSTACKS)
                    .map(d => ({ index: d, selected: false, tracks: [] }));

                this.linearStacks = this.g.selectAll("g.SSC-LinearStack")
                    .data(this.linearStackData)
                    .enter()
                    .append("g")
                    .attr("class", "SSC-LinearStack")
                    .attr("transform", d => "translate(" + ((d.index % nSTACKS) * componentWidth) + "," + (Math.floor(d.index / nSTACKS) * componentHeight) + ")");

                this.linearStacks.append("circle")
                    .attr("cx", componentWidth / 2)
                    .attr("cy", componentHeight / 2)
                    .attr("r", Math.min(componentWidth, componentHeight) * 1 / 3);
            }

            draw(event, selectedTrdTrack) {
                const trdTracks = getTrdTracks(event);

                for (const lsd of this.linearStackData) {
                    lsd.tracks = [];
                    lsd.selected = false;
                }

                for (const trdTrack of trdTracks) {
                    this.linearStackData[trdTrack.LinearStackIndex].tracks.push(trdTrack);
                    if (selectedTrdTrack != null && trdTrack.Index == selectedTrdTrack.index)
                        this.linearStackData[trdTrack.LinearStackIndex].selected = true;
                }

                this.g.selectAll("g.SSC-LinearStack")
                    .classed("SSC-hit", d => d.tracks.length > 0)
                    .classed("SSC-selected", d => d.selected);
            }
        }

        class SectorLayerComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                const minRadius = 30;
                const layerHeight = 10;

                this.g = parent.append("g").attr("class", "stackSector");

                this.sectorLayerData = d3.range(nSECTORS * nLAYERS)
                    .map(d => {
                        const layer = d % nLAYERS;
                        const height = 10 + layer * 3.6;
                        return {
                            index: d,
                            sector: Math.floor(d / nLAYERS),
                            layer: layer,
                            tracks: [],
                            x: minRadius + layerHeight * layer,
                            y: -height / 2,
                            width: layerHeight,
                            height: height
                        };
                    });

                this.sectorLayers = this.g.selectAll("g.SLC-Supermodule")
                    .data(this.sectorLayerData)
                    .enter()
                    .append("g")
                    .attr("class", "SLC-Supermodule ")
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")rotate(" + (-10 - d.sector / nSECTORS * 360) + ")");

                this.sectorLayers.append("rect")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("width", d => d.width)
                    .attr("height", d => d.height);
            }

            draw(event, selectedTracklets) {
                const trdTracklets = event.TrdTracklets.map(parseTrdTracklet);

                for (const sld of this.sectorLayerData) {
                    sld.tracks = [];
                    sld.selected = false;
                }

                for (const trdTracklet of trdTracklets) {
                    const sld = this.sectorLayerData[trdTracklet.Sector * nLAYERS + trdTracklet.Layer];
                    sld.tracks.push(trdTracklet);
                    for (const selTracklet of selectedTracklets)
                        if (trdTracklet.Index == selTracklet.index)
                            sld.selected = true;
                }

                this.g.selectAll("g.SLC-Supermodule")
                    .classed("SLC-hit", d => d.tracks.length > 0)
                    .classed("SLC-selected", d => d.selected);
            }
        }

        const STACK_LAYER_WIDTHS = [
            [110, 85, 60, 85, 110],
            [100, 80, 60, 80, 100],
            [90, 75, 60, 75, 90],
            [80, 70, 60, 70, 80],
            [70, 65, 60, 65, 70],
            [70, 65, 60, 65, 70],
        ];

        class StackLayerComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nLAYERS;

                const layerHeight = 30;

                this.g = parent.append("g").attr("class", "stackLayer");

                this.stackLayerData = d3.range(nSTACKS * nLAYERS)
                    .map(d => {
                        const layer = d % nLAYERS;
                        const stack = Math.floor(d / nLAYERS);
                        let x = -STACK_LAYER_WIDTHS[layer].reduce((a, b) => a + b) / 2;

                        let stackIndex = 0, width = 0;
                        while (stackIndex < stack)
                            x += STACK_LAYER_WIDTHS[layer][stackIndex++];
                        width = STACK_LAYER_WIDTHS[layer][stackIndex];

                        return {
                            index: d,
                            stack: stack,
                            layer: layer,
                            x: x,
                            y: (layer - 3) * layerHeight,
                            width: width,
                            height: layerHeight,
                            tracks: [],
                            selected: false
                        };
                    });

                this.stackLayers = this.g.selectAll("g.STLC-roc")
                    .data(this.stackLayerData)
                    .enter()
                    .append("g")
                    .attr("class", "STLC-roc")
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")");

                this.stackLayers.append("rect")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("width", d => d.width)
                    .attr("height", d => d.height);
            }

            draw(event, selectedTracklets) {
                const trdTracklets = event.TrdTracklets.map(parseTrdTracklet);

                for (const sld of this.stackLayerData) {
                    sld.tracks = [];
                    sld.selected = false;
                }

                for (const trdTracklet of trdTracklets) {
                    const sld = this.stackLayerData[trdTracklet.Stack * nSTACKS + trdTracklet.Layer];
                    sld.tracks.push(trdTracklet);
                    for (const selTracklet of selectedTracklets)
                        if (trdTracklet.Index == selTracklet.index)
                            sld.selected = true;
                }

                this.g.selectAll("g.STLC-roc")
                    .classed("STLC-hit", d => d.tracks.length > 0)
                    .classed("STLC-selected", d => d.selected);
            }
        }

    </script>
    <script>
        // JSTree conversion functions
        function trdTrackletToJseTreeNode(parentId, t) {
            return {
                id: parentId + "_L" + t.index,
                text: "Tracklet " + t.Id,
                data: t,
                type: "TrdTracklet"
            };
        }

        function trdTrackToJSTreeNode(parentId, t) {
            return {
                id: parentId + "_T" + t.index,
                text: "TrdTrack " + t.Id,
                data: t,
                type: "TrdTrack",
                children: t.TrdTracklets.map(tlt => trdTrackletToJseTreeNode(parentId + "_T" + t.index, tlt))
            };
        }

        function eventToJSTreeNode(e, index) {
            const id = "E" + index;
            return {
                id: id,
                text: "Event " + e.Event,
                type: "Event",
                data: e,
                state: {
                    opened: false,
                },
                children:
                    e.TrdTracks.map(tr => trdTrackToJSTreeNode(id, tr))
                        .concat([{
                            id: id + "_CTracklets",
                            text: "Tracklets",
                            children: e.TrdTracklets.map(tlt => trdTrackletToJseTreeNode(id, tlt))
                        }])
            };
        }
    </script>
    <script>
        // Event Display
        const stackSector = new StackSectorComponent(100, 200, d3.select("#stackSector")
            .attr("viewBox", "0 0 100 200"));
        const sectorLayer = new SectorLayerComponent(200, 200, d3.select("#sectorLayer")
            .attr("viewBox", "0 0 200 200"));
        const stackLayer = new StackLayerComponent(600, 300, d3.select("#stackLayer")
            .attr("viewBox", "0 0 600 300").attr("style", "border: 1px solid black"));
        const data = getData();

        for (const event of data) {
            for (let index = 0; index < event.TrdTracklets.length; index++) {
                event.TrdTracklets[index].index = index;
            }

            for (let trdTrackIndex = 0; trdTrackIndex < event.TrdTracks.length; trdTrackIndex++) {
                event.TrdTracks[trdTrackIndex].index = trdTrackIndex;

                for (const trackTracklet of event.TrdTracks[trdTrackIndex].TrdTracklets) {
                    for (const trdTracklet of event.TrdTracklets)
                        if (trdTracklet.Ref === trackTracklet.Ref)
                            trackTracklet.index = trdTracklet.index;
                }
            }
        }

        const treeData = data.map(eventToJSTreeNode);

        function treeSelect(event, eventData) {
            const ids = eventData.node.id.split("_").map(d => [d[0], d.slice(1)]);
            var event = null, trdTrack = null, trdTracklets = [];
            for (const id of ids) {
                const prefix = id[0];
                const index = id[1];
                //console.log(prefix, index);
                if (prefix == "E")
                    event = data[+index];

                if (prefix == "T" && event != null) {
                    trdTrack = event.TrdTracks[+index];
                    trdTracklets = trdTrack.TrdTracklets;
                }

                if (prefix == "L" && event != null) {
                    trdTracklets = [event.TrdTracklets[+index]];
                }
            }

            if (event != null) {
                stackSector.draw(event, trdTrack);
                sectorLayer.draw(event, trdTracklets);
                stackLayer.draw(event, trdTracklets);
            }
        }

        $("#dataTree")
            .on("hover_node.jstree", treeSelect)
            .jstree({
                'core': {
                    'themes': {
                        'name': 'proton',
                        'responsive': true
                    },
                    'data': treeData
                }
            })
    </script>
</body>

</html>