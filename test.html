<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Page Title</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- <link rel="stylesheet" type="text/css" media="screen" href="main.css"> -->
    <link href='./bootstrap/css/bootstrap.min.css' rel='stylesheet' />
    <link href='./proton/style.min.css' rel='stylesheet' />
    <script src="d3.min.js"></script>
    <script src="jquery.min.js"></script>
    <script src="jstree.min.js"></script>
    <script src="data.js"></script>
    <style>
        .SSC-LinearStack {
            fill: lightslategray;
            stroke: none;
        }

        .SSC-LinearStack.SSC-hit {
            fill: red;
            stroke: black;
        }

        .SLC-Supermodule {
            fill: lightslategray;
            stroke: black;
        }

        .SLC-Supermodule.SLC-hit {
            fill: red;
            stroke: black;
        }
    </style>
</head>

<body>
    <div style="width: 200px; max-height: 400px; overflow: auto; display: inline-block; vertical-align: top;">
        <div id="dataTree">

        </div>

    </div>
    <div style="display: inline-block;">
        <svg id="stackSector" width="200px">

        </svg>
    </div>
    <div style="display: inline-block;">
        <svg id="sectorLayer" width="400px">

        </svg>
    </div>
    <script>
        // Constants
        const nSTACKS = 5;
        const nSECTORS = 18;
        const nLAYERS = 6;
        const nLINEARSTACKS = nSTACKS * nSECTORS;

        // Conventions
        // LinearStackIndex = Sector * nSTACKS + Stack
        // Detector = LinearStackIndex * nLAYERS + Layer

        // Common functions
        function DetectorToStack(detector) { return Math.floor((detector % (nSTACKS * nLAYERS)) / nLAYERS); } // convert detector (=chamber) number 0-539 to local stack index 0-4
        function DetectorToLayer(detector) { return detector % nLAYERS; } // convert detector (=chamber) number 0-539 to local layer 0-5
        function DetectorToLinearStackIndex(detector) { return Math.floor(detector / nLAYERS); } // convert TRD detector/chamber 0-539 index to linear stack index 0-89
        function DetectorToSector(detector) { return Math.floor(detector / nLAYERS / nSTACKS); } // convert linear stack index 0-89 to TRD sector 0-17
        function StackSectorToLinearStackIndex(stack, sector) { return sector * nSTACKS + stack; } // convert sector 0-17 and stack 0-5 to linear stack index 0-89
    </script>
    <script>
        // Data conversions
        function parseTrdTracklet(t) {
            return {
                Stack: DetectorToStack(t.Detector),
                Sector: DetectorToSector(t.Detector),
                Layer: DetectorToLayer(t.Detector),
                LinearStackIndex: DetectorToLinearStackIndex(t.Detector),
                Chamber: t.HCId % 2,
                Detector: t.Detector,
                HCId: t.HCId,
            };
        }
        function parseTrdTrack(d) {
            return {
                Stack: d.Stack,
                Sector: d.Sector,
                LinearStackIndex: StackSectorToLinearStackIndex(d.Sector, d.Stack),
                Tracklets: d.TrdTracklets.map(parseTrdTracklet)
            };
        }
        function getTrdTracks(event) {
            return event.TRDTracks.map(parseTrdTrack);
        }
    </script>
    <script>
        // D3 components
        class BaseComponent {
            constructor(width, height) {
                this.height = height;
                this.width = width;
            }
        }

        class StackSectorComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                this.g = parent.append("g").attr("class", "stackSector");

                this.linearStackData = d3.range(nLINEARSTACKS)
                    .map(d => ({ index: d, tracks: [] }));

                this.linearStacks = this.g.selectAll("g.SSC-LinearStack")
                    .data(this.linearStackData)
                    .enter()
                    .append("g")
                    .attr("class", "SSC-LinearStack")
                    .attr("transform", d => "translate(" + ((d.index % nSTACKS) * componentWidth) + "," + (Math.floor(d.index / nSTACKS) * componentHeight) + ")");

                this.linearStacks.append("circle")
                    .attr("cx", componentWidth / 2)
                    .attr("cy", componentHeight / 2)
                    .attr("r", Math.min(componentWidth, componentHeight) * 1 / 3);
            }

            draw(event) {
                const trdTracks = getTrdTracks(event);

                for (const lsd of this.linearStackData)
                    lsd.tracks = [];

                for (const trdTrack of trdTracks) {
                    this.linearStackData[trdTrack.LinearStackIndex].tracks.push(trdTrack);
                }

                this.g.selectAll("g.SSC-LinearStack")
                    .classed("SSC-hit", d => d.tracks.length > 0);
            }
        }

        class SectorLayerComponent extends BaseComponent {
            constructor(width, height, parent) {
                super(width, height);

                const componentWidth = this.componentWidth = this.width / nSTACKS;
                const componentHeight = this.componentHeight = this.height / nSECTORS;

                const minRadius = 30;
                const layerHeight = 10;

                this.g = parent.append("g").attr("class", "stackSector");

                this.sectorLayerData = d3.range(nSECTORS * nLAYERS)
                    .map(d => {
                        const layer = d % nLAYERS;
                        const height = 10 + layer * 3.6;
                        return {
                            index: d,
                            sector: Math.floor(d / nLAYERS),
                            layer: layer,
                            tracks: [],
                            x: minRadius + layerHeight * layer,
                            y: -height / 2,
                            width: layerHeight,
                            height: height
                        };
                    });
                //.slice(0, nLAYERS * 2);

                this.sectorLayers = this.g.selectAll("g.SLC-Supermodule")
                    .data(this.sectorLayerData)
                    .enter()
                    .append("g")
                    .attr("class", "SLC-Supermodule ")
                    .attr("transform", d => "translate(" + (this.width / 2) + "," + (this.height / 2) + ")rotate(" + (-10 - d.sector / nSECTORS * 360) + ")");

                // this.sectorLayers.append("circle")
                //     .attr("cx", d => (height / 10) * (3 * d.layer / nLAYERS + 2))  
                //     .attr("cy", 0)
                //     .attr("r", 5);

                this.sectorLayers.append("rect")
                    .attr("x", d => d.x)
                    .attr("y", d => d.y)
                    .attr("width", d => d.width)
                    .attr("height", d => d.height);
            }

            draw(event) {
                const trdTracklets = event.TRDTracklets.map(parseTrdTracklet);

                for (const sld of this.sectorLayerData)
                    sld.tracks = [];

                for (const trdTracklet of trdTracklets) {
                    this.sectorLayerData[trdTracklet.Sector * nLAYERS + trdTracklet.Layer].tracks.push(trdTracklet);
                }

                this.g.selectAll("g.SLC-Supermodule")
                    .classed("SLC-hit", d => d.tracks.length > 0);
            }
        }
    </script>
    <script>
        // JSTree conversion functions
        function trdTrackletToJseTreeNode(t) {
            return {
                id: t.Ref,
                text: "Tracklet " + t.Id
            };
        }

        function trdTrackToJSTreeNode(t) {
            return {
                id: t.Ref,
                text: "TrdTrack " + t.Id,
                children: t.TrdTracklets.map(trdTrackletToJseTreeNode)
            };
        }
        function eventToJSTreeNode(e) {
            return {
                id: e.Event,
                text: "Event " + e.Event,
                children:
                    e.TRDTracks.map(trdTrackToJSTreeNode)
                        .concat([{
                            text: "Tracklets",
                            children: e.TRDTracklets.map(trdTrackletToJseTreeNode)
                        }])
            };
        }
    </script>
    <script>
        // Event Display
        const stackSector = new StackSectorComponent(100, 200, d3.select("#stackSector").attr("viewBox", "0 0 100 200"));
        const sectorLayer = new SectorLayerComponent(200, 200, d3.select("#sectorLayer").attr("viewBox", "0 0 200 200"));
        const data = getData();

        stackSector.draw(data[0]);
        sectorLayer.draw(data[0]);

        $("#dataTree").jstree({
            'core': {
                'themes': {
                    'name': 'proton',
                    'responsive': true
                },
                'data': data.map(eventToJSTreeNode)
            }
        })
    </script>
</body>

</html>